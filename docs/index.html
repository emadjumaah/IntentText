<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IntentText Playground</title>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: #ffffff;
        color: #111827;
      }
      header {
        padding: 20px 18px;
        border-bottom: 1px solid #e5e7eb;
        position: sticky;
        top: 0;
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
      }
      header h1 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
      }
      header p {
        margin: 6px 0 0;
        font-size: 13px;
        color: #6b7280;
      }
      main {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
        padding: 14px;
        max-width: 1280px;
        margin: 0 auto;
      }
      @media (max-width: 960px) {
        main {
          grid-template-columns: 1fr;
        }
      }
      .panel {
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        overflow: hidden;
        background: #fff;
        min-height: calc(100vh - 140px);
        display: flex;
        flex-direction: column;
      }
      .panel header {
        position: static;
        background: #fafafa;
        border-bottom: 1px solid #e5e7eb;
        padding: 10px 12px;
      }
      .panel header h2 {
        margin: 0;
        font-size: 13px;
        font-weight: 600;
        color: #374151;
      }
      textarea {
        flex: 1;
        width: 100%;
        border: 0;
        outline: none;
        padding: 12px;
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", monospace;
        font-size: 13px;
        line-height: 1.5;
        resize: none;
      }
      .actions {
        display: flex;
        gap: 10px;
        padding: 10px 12px;
        border-top: 1px solid #e5e7eb;
        background: #fff;
        align-items: center;
      }
      button {
        appearance: none;
        border: 1px solid #e5e7eb;
        background: #111827;
        color: #fff;
        padding: 8px 10px;
        border-radius: 10px;
        font-size: 13px;
        cursor: pointer;
      }
      button.secondary {
        background: #fff;
        color: #111827;
      }
      .status {
        margin-left: auto;
        font-size: 12px;
        color: #6b7280;
      }
      #output {
        padding: 0;
        margin: 0;
      }
      .error {
        padding: 10px 12px;
        border-top: 1px solid #e5e7eb;
        background: #fff;
        color: #b91c1c;
        font-size: 13px;
        display: none;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>IntentText Playground</h1>
      <p>
        Type IntentText on the left. The preview on the right is rendered using
        a simplified in-browser parser.
      </p>
    </header>

    <main>
      <section class="panel">
        <header><h2>Editor (.it)</h2></header>
        <textarea id="input" spellcheck="false"></textarea>
        <div class="actions">
          <button onclick="render()">Render</button>
          <button class="secondary" onclick="loadExample()">
            Load example
          </button>
          <div class="status" id="status"></div>
        </div>
        <div class="error" id="error"></div>
      </section>

      <section class="panel">
        <header><h2>Preview (HTML)</h2></header>
        <div id="output"></div>
      </section>
    </main>

    <script>
      const KEYWORDS = new Set([
        "title",
        "summary",
        "section",
        "sub",
        "divider",
        "note",
        "headers",
        "row",
        "task",
        "done",
        "question",
        "image",
        "link",
        "ref",
        "code",
        "end",
      ]);

      function escapeHtml(text) {
        return String(text)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function sanitizeUrl(url) {
        const trimmed = String(url).trim();
        if (trimmed === "") return "";

        if (
          trimmed.startsWith("/") ||
          trimmed.startsWith("./") ||
          trimmed.startsWith("../") ||
          trimmed.startsWith("#")
        ) {
          return trimmed;
        }

        const lower = trimmed.toLowerCase();
        if (!lower.includes(":") && !lower.startsWith("//")) return trimmed;

        if (
          lower.startsWith("http://") ||
          lower.startsWith("https://") ||
          lower.startsWith("mailto:") ||
          lower.startsWith("tel:")
        ) {
          return trimmed;
        }

        return "#";
      }

      function convertFormattedTextToHTML(text) {
        let result = escapeHtml(text);
        result = result.replace(/\*([^*]+)\*/g, "<strong>$1</strong>");
        result = result.replace(/_([^_]+)_/g, "<em>$1</em>");
        result = result.replace(/~([^~]+)~/g, "<del>$1</del>");
        result = result.replace(/```([\s\S]+?)```/g, "<code>$1</code>");
        return result;
      }

      function parseLineToBlock(line) {
        const trimmed = line.trim();
        if (!trimmed) return null;

        const keywordMatch = trimmed.match(/^([a-zA-Z]+):\s*(.*)$/);
        if (keywordMatch) {
          const keyword = keywordMatch[1].toLowerCase();
          const rest = keywordMatch[2];

          if (!KEYWORDS.has(keyword)) {
            return { type: "body-text", original: trimmed, content: trimmed };
          }

          let content = "";
          const properties = {};

          if (keyword === "headers" || keyword === "row") {
            content = rest;
          } else {
            const parts = rest.split(" | ");
            content = parts[0] || "";
            for (let i = 1; i < parts.length; i++) {
              const m = parts[i].match(/^([^:]+):\s*(.*)$/);
              if (m) properties[m[1].trim()] = m[2].trim();
              else content += " | " + parts[i];
            }
          }

          return { type: keyword, original: content, content, properties };
        }

        if (trimmed.startsWith("- ") || trimmed.startsWith("* ")) {
          return {
            type: "list-item",
            original: trimmed.slice(2),
            content: trimmed.slice(2),
          };
        }

        const ordered = trimmed.match(/^(\d+)\.\s+(.+)$/);
        if (ordered) {
          return {
            type: "step-item",
            original: ordered[2],
            content: ordered[2],
          };
        }

        return { type: "body-text", original: trimmed, content: trimmed };
      }

      function renderBlocks(blocks, metadata) {
        const direction =
          metadata.language === "rtl" ? 'dir="rtl"' : 'dir="ltr"';
        const doc = { blocks, metadata };

        function renderBlock(block) {
          const content = convertFormattedTextToHTML(
            block.original || block.content || "",
          );
          const props = block.properties || {};

          switch (block.type) {
            case "title":
              return `<h1 class="intent-title">${content}</h1>`;
            case "summary":
              return `<div class="intent-summary">${content}</div>`;
            case "section":
              return `<h2 class="intent-section">${content}</h2>`;
            case "sub":
              return `<h3 class="intent-sub">${content}</h3>`;
            case "note":
            case "body-text":
              return `<p class="intent-note">${content}</p>`;
            case "divider":
              return `<div class="intent-divider"><hr class="intent-divider-line" />${content ? `<span class="intent-divider-label">${content}</span>` : ""}</div>`;
            case "task":
              return `<div class="intent-task"><input class="intent-task-checkbox" type="checkbox" /><span class="intent-task-text">${content}</span><span class="intent-task-meta">${props.owner ? `<span class="intent-task-owner">${escapeHtml(props.owner)}</span>` : ""}${props.due ? `<span class="intent-task-due">${escapeHtml(props.due)}</span>` : ""}</span></div>`;
            case "done":
              return `<div class="intent-task intent-task-done"><input class="intent-task-checkbox" type="checkbox" checked /><span class="intent-task-text intent-task-text-done">${content}</span><span class="intent-task-meta">${props.time ? `<span class="intent-task-time">${escapeHtml(props.time)}</span>` : ""}</span></div>`;
            case "question":
              return `<div class="intent-question"><strong>Question:</strong> ${content}</div>`;
            case "link":
              return `<p class="intent-link"><a href="${escapeHtml(sanitizeUrl(props.to || block.content || ""))}">${content}</a></p>`;
            case "ref": {
              const refTo = escapeHtml(
                sanitizeUrl(props.to || block.content || ""),
              );
              const refText = content || refTo;
              return `<p class="intent-ref"><a href="${refTo}">${refText}</a></p>`;
            }
            case "image": {
              const src = escapeHtml(sanitizeUrl(props.at || ""));
              return `<figure class="intent-image"><img class="intent-image-img" src="${src}" alt="${content}" />${props.caption ? `<figcaption class="intent-image-caption">${escapeHtml(props.caption)}</figcaption>` : ""}</figure>`;
            }
            case "headers": {
              const headers = String(block.content)
                .split("|")
                .map((x) => x.trim())
                .filter(Boolean);
              return `<table class="intent-table"><thead><tr>${headers
                .map((h) => `<th class="intent-table-th">${escapeHtml(h)}</th>`)
                .join("")}</tr></thead><tbody>`;
            }
            case "row": {
              const cells = String(block.content)
                .split("|")
                .map((x) => x.trim())
                .filter(Boolean);
              return `<tr class="intent-row">${cells
                .map((c) => `<td class="intent-table-td">${escapeHtml(c)}</td>`)
                .join("")}</tr>`;
            }
            case "code":
              return `<pre class="intent-code"><code>${escapeHtml(block.content || "")}</code></pre>`;
            case "list-item":
              return `<li class="intent-list-item">${content}</li>`;
            case "step-item":
              return `<li class="intent-step-item">${content}</li>`;
            default:
              return `<div class="intent-unknown"><small class="intent-unknown-type">[${escapeHtml(block.type)}]</small>${content}</div>`;
          }
        }

        let html = "";
        let inTable = false;
        let tableContent = "";
        let listMode = null;

        for (let i = 0; i < blocks.length; i++) {
          const b = blocks[i];

          if (b.type === "headers") {
            if (inTable) {
              html += tableContent + "</tbody></table>";
            }
            inTable = true;
            tableContent = renderBlock(b);
            continue;
          }

          if (b.type === "row") {
            if (inTable) tableContent += renderBlock(b);
            else
              html += `<table class="intent-table"><tbody>${renderBlock(b)}</tbody></table>`;
            continue;
          }

          if (inTable) {
            html += tableContent + "</tbody></table>";
            inTable = false;
            tableContent = "";
          }

          const isListItem = b.type === "list-item";
          const isStepItem = b.type === "step-item";

          if (isListItem || isStepItem) {
            const nextMode = isStepItem ? "ol" : "ul";
            if (listMode !== nextMode) {
              if (listMode) html += `</${listMode}>`;
              listMode = nextMode;
              html += `<${listMode}>`;
            }
            html += renderBlock(b);
            continue;
          }

          if (listMode) {
            html += `</${listMode}>`;
            listMode = null;
          }

          html += renderBlock(b);
        }

        if (listMode) html += `</${listMode}>`;
        if (inTable) html += tableContent + "</tbody></table>";

        return `<div class="intent-document" ${direction}>
<style>
.intent-document{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;line-height:1.65;color:#111827;max-width:760px;margin:0 auto;padding:40px 24px;}
.intent-title{font-size:2rem;line-height:1.2;margin:0 0 16px;text-align:center;letter-spacing:-0.01em;}
.intent-summary{margin:16px 0 24px;padding:12px 14px;border:1px solid #e5e7eb;border-radius:10px;background:#fafafa;color:#374151;}
.intent-section{margin:28px 0 10px;font-size:1.25rem;line-height:1.3;}
.intent-sub{margin:20px 0 8px;font-size:1.05rem;line-height:1.3;color:#374151;}
.intent-note{margin:8px 0;}
.intent-divider{margin:24px 0;position:relative;text-align:center;}
.intent-divider-line{border:none;border-top:1px solid #e5e7eb;margin:0;}
.intent-divider-label{display:inline-block;margin-top:-10px;padding:0 10px;background:white;color:#6b7280;font-size:0.875rem;position:relative;top:-10px;}
.intent-task{display:flex;align-items:flex-start;gap:10px;padding:10px 12px;border:1px solid #e5e7eb;border-radius:10px;margin:8px 0;}
.intent-task-checkbox{margin-top:3px;}
.intent-task-text{flex:1;}
.intent-task-meta{display:flex;gap:10px;color:#6b7280;font-size:0.85rem;white-space:nowrap;}
.intent-task-text-done{text-decoration:line-through;color:#6b7280;}
.intent-question{margin:12px 0;padding:12px 14px;border-left:3px solid #e5e7eb;background:#fafafa;border-radius:10px;}
.intent-code{margin:12px 0;padding:12px 14px;border:1px solid #e5e7eb;border-radius:10px;background:#0b1020;color:#e5e7eb;overflow-x:auto;}
.intent-code code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono',monospace;font-size:0.9rem;}
.intent-table{width:100%;border-collapse:collapse;margin:14px 0;border:1px solid #e5e7eb;border-radius:10px;overflow:hidden;}
.intent-table th,.intent-table td{padding:10px 12px;border-top:1px solid #e5e7eb;text-align:left;vertical-align:top;}
.intent-table thead th{background:#fafafa;border-top:none;font-weight:600;color:#374151;}
.intent-image{margin:14px 0;}
.intent-image-img{max-width:100%;height:auto;border-radius:12px;border:1px solid #e5e7eb;}
.intent-image-caption{margin-top:8px;color:#6b7280;font-size:0.875rem;text-align:center;}
.intent-link{margin:8px 0;}
.intent-link a{color:#2563eb;text-decoration:none;}
.intent-link a:hover{text-decoration:underline;}
.intent-ref{margin:8px 0;}
.intent-ref a{color:#2563eb;text-decoration:none;font-style:italic;}
.intent-ref a:hover{text-decoration:underline;}
.intent-unknown{margin:10px 0;padding:10px 12px;border:1px dashed #e5e7eb;border-radius:10px;color:#6b7280;}
.intent-unknown-type{margin-right:6px;color:#9ca3af;}
ul,ol{margin:10px 0 10px 22px;padding:0;}
li{margin:6px 0;}
</style>
${html}
</div>`;
      }

      function parseIntentText(content) {
        const lines = content.split(/\r?\n/);
        const blocks = [];
        let inCode = false;
        let codeLines = [];

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const trimmed = line.trim();

          if (inCode) {
            if (trimmed.toLowerCase() === "end:") {
              blocks.push({ type: "code", content: codeLines.join("\n") });
              inCode = false;
              codeLines = [];
            } else {
              codeLines.push(line);
            }
            continue;
          }

          const codeStart = trimmed.match(/^code:\s*(.*)$/);
          if (codeStart) {
            const rest = codeStart[1];
            if (rest === "") {
              inCode = true;
            } else {
              blocks.push({ type: "code", content: rest });
            }
            continue;
          }

          if (trimmed.toLowerCase() === "end:") {
            // ignore in playground
            continue;
          }

          const b = parseLineToBlock(line);
          if (b) blocks.push(b);
        }

        if (inCode) {
          blocks.push({ type: "code", content: codeLines.join("\n") });
        }

        const text = blocks.map((b) => String(b.content || "")).join("\n");
        const hasArabic = /[\u0600-\u06FF]/.test(text);

        const title = blocks.find((b) => b.type === "title")?.content;
        const summary = blocks.find((b) => b.type === "summary")?.content;

        return {
          blocks,
          metadata: { title, summary, language: hasArabic ? "rtl" : "ltr" },
        };
      }

      function loadExample() {
        document.getElementById("input").value =
          `title: *Project Dalil* Launch Plan
summary: Finalizing the deployment for the AI-Agent hub in _Doha_.

section: Logistics & Equipment
headers: Item | Location | Status
row: Dell Server | Rack 04 | Delivered
row: Fiber Cables | Storage | ~Missing~ Ordered

section: Team Tasks
- Set up the environment.
- Configure the firewall.
- task: Update README | owner: Sarah | due: Monday

task: Database migration | owner: Ahmed | due: Sunday
done: Secure the domain name | time: 09:00 AM

section: Security Questions
question: Who has the _Master Key_ for the server room?
note: Surveillance footage is saved at ``` /
          logs /
          cam1```.

section: Setup Script
code:
#!/bin/bash
apt-get update && apt-get install -y nginx
end:

divider: End of Technical Sections

link: *Full Documentation* | to: https://dalil.ai/docs | title: Dalil Docs
image: *Launch Banner* | at: placeholder.svg | caption: Project Dalil launch artwork`;
        render();
      }

      function render() {
        const input = document.getElementById("input").value;
        const output = document.getElementById("output");
        const error = document.getElementById("error");
        const status = document.getElementById("status");

        try {
          const doc = parseIntentText(input);
          output.innerHTML = renderBlocks(doc.blocks, doc.metadata);
          error.style.display = "none";
          status.textContent = `${doc.blocks.length} blocks`;
        } catch (e) {
          output.innerHTML = "";
          error.style.display = "block";
          error.textContent = String(e && e.message ? e.message : e);
          status.textContent = "";
        }
      }

      window.addEventListener("load", () => {
        loadExample();
      });
    </script>
  </body>
</html>
