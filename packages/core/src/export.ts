import * as fs from "fs";
import * as path from "path";
import { parseIntentText } from "./parser";
import { renderHTML } from "./renderer";
import { IntentDocument, IntentBlock } from "./types";
import { processDocument } from "./templates";

export interface ExportOptions {
  inputDir: string;
  outputDir: string;
  template?: string; // Path to HTML template file
  baseUrl?: string;
  title?: string;
  description?: string;
  theme?: "default" | "minimal" | "docs";
  includeDrafts?: boolean;
}

export interface ExportResult {
  files: string[];
  errors: string[];
  warnings: string[];
}

interface PageData {
  path: string;
  title: string;
  summary?: string;
  blocks: IntentBlock[];
  document: IntentDocument;
}

/**
 * Default HTML template for static site generation
 */
const DEFAULT_TEMPLATE = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{title}}</title>
  <style>
    :root {
      --bg: #fafafa;
      --fg: #111;
      --muted: #666;
      --accent: #2563eb;
      --border: #e5e7eb;
    }
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      line-height: 1.6;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      background: var(--bg);
      color: var(--fg);
    }
    .nav {
      margin-bottom: 2rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--border);
    }
    .nav a { color: var(--accent); text-decoration: none; }
    .nav a:hover { text-decoration: underline; }
    footer {
      margin-top: 4rem;
      padding-top: 2rem;
      border-top: 1px solid var(--border);
      color: var(--muted);
      font-size: 0.875rem;
    }
    {{styles}}
  </style>
</head>
<body>
  <nav class="nav">
    <a href="/">← Home</a>
  </nav>
  <main>
    {{content}}
  </main>
  <footer>
    Generated by IntentText
  </footer>
</body>
</html>`;

const MINIMAL_TEMPLATE = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{title}}</title>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 70ch; margin: 2rem auto; padding: 0 1rem; line-height: 1.6; }
    {{styles}}
  </style>
</head>
<body>
  {{content}}
</body>
</html>`;

/**
 * Find all .it files in a directory recursively
 */
function findItFiles(dir: string): string[] {
  const files: string[] = [];
  
  if (!fs.existsSync(dir)) {
    return files;
  }
  
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory() && !entry.name.startsWith(".") && entry.name !== "node_modules") {
      files.push(...findItFiles(fullPath));
    } else if (entry.isFile() && entry.name.endsWith(".it")) {
      files.push(fullPath);
    }
  }
  
  return files;
}

/**
 * Parse an .it file and extract metadata
 */
function parsePage(filePath: string): PageData | null {
  try {
    const content = fs.readFileSync(filePath, "utf-8");
    const document = parseIntentText(content);
    
    // Find title
    const titleBlock = document.blocks.find(b => b.type === "title");
    const title = titleBlock?.content || path.basename(filePath, ".it");
    
    // Find summary
    const summaryBlock = document.blocks.find(b => b.type === "summary");
    const summary = summaryBlock?.content;
    
    return {
      path: filePath,
      title,
      summary,
      blocks: document.blocks,
      document,
    };
  } catch (error) {
    return null;
  }
}

/**
 * Generate navigation links from pages
 */
function generateNavigation(pages: PageData[], currentPath: string): string {
  const links = pages.map(page => {
    const relativePath = path.relative(currentPath, page.path).replace(/\\/g, "/");
    const isActive = page.path === currentPath;
    const href = relativePath.replace(/\.it$/, ".html");
    return `<a href="${href}"${isActive ? ' class="active"' : ''}>${page.title}</a>`;
  });
  
  return `<nav class="nav">${links.join(" | ")}</nav>`;
}

/**
 * Apply template substitutions
 */
function applyTemplate(
  template: string,
  data: { title: string; content: string; styles: string; nav: string }
): string {
  return template
    .replace(/\{\{title\}\}/g, data.title)
    .replace(/\{\{content\}\}/g, data.content)
    .replace(/\{\{styles\}\}/g, data.styles)
    .replace(/\{\{nav\}\}/g, data.nav);
}

/**
 * Get theme styles
 */
function getThemeStyles(theme: ExportOptions["theme"]): string {
  const themes = {
    default: `
      .intent-title { font-size: 2rem; font-weight: 700; margin-bottom: 1rem; }
      .intent-section { font-size: 1.5rem; font-weight: 600; margin: 2rem 0 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border); }
      .intent-sub { font-size: 1.25rem; font-weight: 600; margin: 1.5rem 0 0.75rem; }
      .intent-note { background: #f9fafb; padding: 1rem; border-radius: 8px; margin: 1rem 0; }
      .intent-task, .intent-done { display: flex; align-items: baseline; gap: 0.5rem; margin: 0.5rem 0; }
      .intent-task::before { content: "☐"; color: var(--muted); }
      .intent-done::before { content: "☑"; color: #16a34a; }
      .intent-question { background: #fef3c7; padding: 1rem; border-left: 4px solid #f59e0b; margin: 1rem 0; }
      .intent-image { margin: 1.5rem 0; }
      .intent-image img { max-width: 100%; border-radius: 8px; }
      .intent-table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
      .intent-table th, .intent-table td { padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border); }
      .intent-table th { font-weight: 600; background: #f9fafb; }
      .intent-link a { color: var(--accent); text-decoration: none; }
      .intent-link a:hover { text-decoration: underline; }
      .intent-ref { font-style: italic; }
      .intent-ref a { color: var(--accent); }
      .intent-code { background: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 8px; overflow-x: auto; margin: 1rem 0; }
      .intent-code code { font-family: ui-monospace, monospace; font-size: 0.875rem; }
      .intent-divider { border: none; border-top: 1px solid var(--border); margin: 2rem 0; }
    `,
    minimal: `
      h1, h2, h3 { font-weight: 500; }
      h1 { font-size: 1.75rem; }
      h2 { font-size: 1.5rem; margin-top: 2rem; }
      table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
      th, td { padding: 0.5rem; text-align: left; border-bottom: 1px solid #ddd; }
      code { background: #f5f5f5; padding: 0.2rem 0.4rem; border-radius: 3px; }
      pre { background: #f5f5f5; padding: 1rem; overflow-x: auto; }
    `,
    docs: `
      .nav { position: fixed; left: 0; top: 0; width: 250px; height: 100vh; background: #f8fafc; padding: 2rem; border-right: 1px solid #e2e8f0; }
      .nav a { display: block; padding: 0.5rem 0; color: #475569; text-decoration: none; }
      .nav a:hover, .nav a.active { color: #0f172a; }
      main { margin-left: 250px; padding: 2rem; max-width: none; }
      footer { margin-left: 250px; }
      @media (max-width: 768px) { 
        .nav { position: static; width: auto; height: auto; border-right: none; border-bottom: 1px solid #e2e8f0; } 
        main, footer { margin-left: 0; }
      }
    `,
  };
  
  return themes[theme || "default"];
}

/**
 * Build a static site from .it files
 */
export function buildStaticSite(options: ExportOptions): ExportResult {
  const result: ExportResult = { files: [], errors: [], warnings: [] };
  
  // Create output directory
  if (!fs.existsSync(options.outputDir)) {
    fs.mkdirSync(options.outputDir, { recursive: true });
  }
  
  // Find all .it files
  const itFiles = findItFiles(options.inputDir);
  
  if (itFiles.length === 0) {
    result.warnings.push(`No .it files found in ${options.inputDir}`);
    return result;
  }
  
  // Parse all pages
  const pages: PageData[] = [];
  for (const file of itFiles) {
    const page = parsePage(file);
    if (page) {
      pages.push(page);
    } else {
      result.errors.push(`Failed to parse ${file}`);
    }
  }
  
  // Load custom template if provided
  let template = DEFAULT_TEMPLATE;
  if (options.template && fs.existsSync(options.template)) {
    template = fs.readFileSync(options.template, "utf-8");
  } else if (options.theme === "minimal") {
    template = MINIMAL_TEMPLATE;
  }
  
  const styles = getThemeStyles(options.theme);
  
  // Generate each page
  for (const page of pages) {
    try {
      // Process templates and includes
      const processedDoc = processDocument(page.document, path.dirname(page.path));
      
      // Render HTML
      const htmlContent = renderHTML(processedDoc);
      
      // Generate navigation
      const nav = options.theme === "docs" 
        ? generateNavigation(pages, page.path)
        : '<nav class="nav"><a href="/">← Home</a></nav>';
      
      // Apply template
      const fullHtml = applyTemplate(template, {
        title: page.title,
        content: htmlContent,
        styles,
        nav,
      });
      
      // Calculate output path
      const relativePath = path.relative(options.inputDir, page.path);
      const outputPath = path.join(
        options.outputDir,
        relativePath.replace(/\.it$/, ".html")
      );
      
      // Ensure directory exists
      const outputDir = path.dirname(outputPath);
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }
      
      // Write file
      fs.writeFileSync(outputPath, fullHtml, "utf-8");
      result.files.push(outputPath);
    } catch (error) {
      result.errors.push(`Failed to render ${page.path}: ${(error as Error).message}`);
    }
  }
  
  // Generate index page if it doesn't exist
  const indexPath = path.join(options.outputDir, "index.html");
  if (!fs.existsSync(indexPath) && pages.length > 0) {
    const indexContent = pages.map(p => 
      `<h2><a href="${path.relative(options.outputDir, p.path).replace(/\\/g, "/").replace(/\.it$/, ".html")}">${p.title}</a></h2>
      ${p.summary ? `<p>${p.summary}</p>` : ""}`
    ).join("\n");
    
    const indexHtml = applyTemplate(template, {
      title: options.title || "Index",
      content: `<h1>${options.title || "Documentation"}</h1>${options.description ? `<p>${options.description}</p>` : ""}${indexContent}`,
      styles,
      nav: "",
    });
    
    fs.writeFileSync(indexPath, indexHtml, "utf-8");
    result.files.push(indexPath);
  }
  
  return result;
}

/**
 * CLI helper to format export results
 */
export function formatExportResult(result: ExportResult): string {
  const lines: string[] = [];
  
  if (result.files.length > 0) {
    lines.push(`✓ Generated ${result.files.length} file(s):`);
    for (const file of result.files) {
      lines.push(`  - ${file}`);
    }
  }
  
  if (result.warnings.length > 0) {
    lines.push(`⚠ ${result.warnings.length} warning(s):`);
    for (const warning of result.warnings) {
      lines.push(`  - ${warning}`);
    }
  }
  
  if (result.errors.length > 0) {
    lines.push(`✗ ${result.errors.length} error(s):`);
    for (const error of result.errors) {
      lines.push(`  - ${error}`);
    }
  }
  
  return lines.join("\n");
}
